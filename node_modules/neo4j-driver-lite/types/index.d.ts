import { logging } from './logging';
import { Neo4jError, error, Integer, int, isInt, isPoint, Point, Date, DateTime, Duration, isDate, isDateTime, isDuration, isLocalDateTime, isLocalTime, isTime, LocalDateTime, LocalTime, Time, Node, Path, PathSegment, Relationship, UnboundRelationship, Record, ResultSummary, Result, ConnectionProvider, Driver, QueryResult, ResultObserver, Plan, ProfiledPlan, QueryStatistics, Notification, NotificationPosition, Session, Transaction, ServerInfo, Connection, types as coreTypes, auth } from 'neo4j-driver-core';
declare type AuthToken = coreTypes.AuthToken;
declare type Config = coreTypes.Config;
declare type TrustStrategy = coreTypes.TrustStrategy;
declare type EncryptionLevel = coreTypes.EncryptionLevel;
declare type SessionMode = coreTypes.SessionMode;
/**
 * Construct a new Neo4j Driver. This is your main entry point for this
 * library.
 *
 * ## Configuration
 *
 * This function optionally takes a configuration argument. Available configuration
 * options are as follows:
 *
 *     {
 *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.
 *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF
 *
 *       // Trust strategy to use if encryption is enabled. There is no mode to disable
 *       // trust other than disabling encryption altogether. The reason for
 *       // this is that if you don't know who you are talking to, it is easy for an
 *       // attacker to hijack your encrypted connection, rendering encryption pointless.
 *       //
 *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES is the default choice. For NodeJS environments, this
 *       // means that you trust whatever certificates are in the default trusted certificate
 *       // store of the underlying system. For Browser environments, the trusted certificate
 *       // store is usually managed by the browser. Refer to your system or browser documentation
 *       // if you want to explicitly add a certificate as trusted.
 *       //
 *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is another option for trust verification -
 *       // whenever we establish an encrypted connection, we ensure the host is using
 *       // an encryption certificate that is in, or is signed by, a certificate given
 *       // as trusted through configuration. This option is only available for NodeJS environments.
 *       //
 *       // TRUST_ALL_CERTIFICATES means that you trust everything without any verifications
 *       // steps carried out.  This option is only available for NodeJS environments and should not
 *       // be used on production systems.
 *       trust: "TRUST_SYSTEM_CA_SIGNED_CERTIFICATES" | "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" |
 *       "TRUST_ALL_CERTIFICATES",
 *
 *       // List of one or more paths to trusted encryption certificates. This only
 *       // works in the NodeJS bundle, and only matters if you use "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES".
 *       // The certificate files should be in regular X.509 PEM format.
 *       // For instance, ['./trusted.pem']
 *       trustedCertificates: [],
 *
 *       // The maximum total number of connections allowed to be managed by the connection pool, per host.
 *       // This includes both in-use and idle connections. No maximum connection pool size is imposed
 *       // by default.
 *       maxConnectionPoolSize: 100,
 *
 *       // The maximum allowed lifetime for a pooled connection in milliseconds. Pooled connections older than this
 *       // threshold will be closed and removed from the pool. Such discarding happens during connection acquisition
 *       // so that new session is never backed by an old connection. Setting this option to a low value will cause
 *       // a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime
 *       // to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,
 *       // etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero
 *       // and negative values result in lifetime not being checked.
 *       maxConnectionLifetime: 60 * 60 * 1000, // 1 hour
 *
 *       // The maximum amount of time to wait to acquire a connection from the pool (to either create a new
 *       // connection or borrow an existing one.
 *       connectionAcquisitionTimeout: 60000, // 1 minute
 *
 *       // Specify the maximum time in milliseconds transactions are allowed to retry via
 *       // `Session#readTransaction()` and `Session#writeTransaction()` functions.
 *       // These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient
 *       // errors with exponential backoff using initial delay of 1 second.
 *       // Default value is 30000 which is 30 seconds.
 *       maxTransactionRetryTime: 30000, // 30 seconds
 *
 *       // Specify socket connection timeout in milliseconds. Numeric values are expected. Negative and zero values
 *       // result in no timeout being applied. Connection establishment will be then bound by the timeout configured
 *       // on the operating system level. Default value is 30000, which is 30 seconds.
 *       connectionTimeout: 30000, // 30 seconds
 *
 *       // Make this driver always return native JavaScript numbers for integer values, instead of the
 *       // dedicated {@link Integer} class. Values that do not fit in native number bit range will be represented as
 *       // `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.
 *       // **Warning:** ResultSummary It is not always safe to enable this setting when JavaScript applications are not the only ones
 *       // interacting with the database. Stored numbers might in such case be not representable by native
 *       // {@link Number} type and thus driver will return lossy values. This might also happen when data was
 *       // initially imported using neo4j import tool and contained numbers larger than
 *       // `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.
 *       // Default value for this option is `false` because native JavaScript numbers might result
 *       // in loss of precision in the general case.
 *       disableLosslessIntegers: false,
 *
 *       // Make this driver always return native Javascript {@link BigInt} for integer values, instead of the dedicated {@link Integer} class or {@link Number}.
 *       //
 *       // Default value for this option is `false` for backwards compatibility.
 *       //
 *       // **Warning:** `BigInt` doesn't implement the method `toJSON`. In maner of serialize it as `json`, It's needed to add a custom implementation of the `toJSON` on the
 *       // `BigInt.prototype` {@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json}
 *       useBigInt: false,
 *
 *       // Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.
 *       //
 *       // Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and
 *       // its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all
 *       // levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.
 *       //
 *       // Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should
 *       // take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations
 *       // because it is often executed on a hot path.
 *       //
 *       // No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.
 *       logging: {
 *         level: 'info',
 *         logger: (level, message) => console.log(level + ' ' + message)
 *       },
 *
 *       // Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.
 *       // Such resolution happens:
 *       //  * during the very first rediscovery when driver is created
 *       //  * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address
 *       //
 *       // In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.
 *       // In browser environment driver uses the initial address as-is.
 *       // Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.
 *       // Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses
 *       // or array of addresses directly.
 *       resolver: function(address) {
 *         return ['127.0.0.1:8888', 'fallback.db.com:7687'];
 *       },
 *
 *      // Optionally override the default user agent name.
 *       userAgent: USER_AGENT
 *     }
 *
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {Map<string,string>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Object} config Configuration object. See the configuration section above for details.
 * @returns {Driver}
 */
declare function driver(url: string, authToken: AuthToken, config?: Config): Driver;
/**
 * Object containing constructors for all neo4j types.
 */
declare const types: {
    Node: typeof Node;
    Relationship: typeof Relationship;
    UnboundRelationship: typeof UnboundRelationship;
    PathSegment: typeof PathSegment;
    Path: typeof Path;
    Result: typeof Result;
    ResultSummary: typeof ResultSummary;
    Record: typeof Record;
    Point: typeof Point;
    Date: typeof Date;
    DateTime: typeof DateTime;
    Duration: typeof Duration;
    LocalDateTime: typeof LocalDateTime;
    LocalTime: typeof LocalTime;
    Time: typeof Time;
    Integer: typeof Integer;
};
/**
 * Object containing string constants representing session access modes.
 */
declare const session: {
    READ: coreTypes.SessionMode;
    WRITE: coreTypes.SessionMode;
};
/**
 * Object containing functions to work with {@link Integer} objects.
 */
declare const integer: {
    toNumber: typeof Integer.toNumber;
    toString: typeof Integer.toString;
    inSafeRange: typeof Integer.inSafeRange;
};
/**
 * Object containing functions to work with spatial types, like {@link Point}.
 */
declare const spatial: {
    isPoint: typeof isPoint;
};
/**
 * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.
 */
declare const temporal: {
    isDuration: typeof isDuration;
    isLocalTime: typeof isLocalTime;
    isTime: typeof isTime;
    isDate: typeof isDate;
    isLocalDateTime: typeof isLocalDateTime;
    isDateTime: typeof isDateTime;
};
/**
 * @private
 */
declare const forExport: {
    driver: typeof driver;
    int: typeof Integer.fromValue;
    isInt: typeof Integer.isInteger;
    isPoint: typeof isPoint;
    isDuration: typeof isDuration;
    isLocalTime: typeof isLocalTime;
    isTime: typeof isTime;
    isDate: typeof isDate;
    isLocalDateTime: typeof isLocalDateTime;
    isDateTime: typeof isDateTime;
    integer: {
        toNumber: typeof Integer.toNumber;
        toString: typeof Integer.toString;
        inSafeRange: typeof Integer.inSafeRange;
    };
    Neo4jError: typeof Neo4jError;
    auth: {
        basic: (username: string, password: string, realm?: string | undefined) => {
            scheme: string;
            principal: string;
            credentials: string;
            realm: string;
        } | {
            scheme: string;
            principal: string;
            credentials: string;
            realm?: undefined;
        };
        kerberos: (base64EncodedTicket: string) => {
            scheme: string;
            principal: string;
            credentials: string;
        };
        bearer: (base64EncodedToken: string) => {
            scheme: string;
            credentials: string;
        };
        custom: (principal: string, credentials: string, realm: string, scheme: string, parameters?: string | undefined) => {
            scheme: string;
            principal: string;
            credentials: string;
            realm: string;
            parameters: string;
        } | {
            scheme: string;
            principal: string;
            credentials: string;
            realm: string;
            parameters?: undefined;
        };
    };
    logging: {
        console: (level: coreTypes.LogLevel) => {
            level: coreTypes.LogLevel;
            logger: (level: coreTypes.LogLevel, message: string) => void;
        };
    };
    types: {
        Node: typeof Node;
        Relationship: typeof Relationship;
        UnboundRelationship: typeof UnboundRelationship;
        PathSegment: typeof PathSegment;
        Path: typeof Path;
        Result: typeof Result;
        ResultSummary: typeof ResultSummary;
        Record: typeof Record;
        Point: typeof Point;
        Date: typeof Date;
        DateTime: typeof DateTime;
        Duration: typeof Duration;
        LocalDateTime: typeof LocalDateTime;
        LocalTime: typeof LocalTime;
        Time: typeof Time;
        Integer: typeof Integer;
    };
    session: {
        READ: coreTypes.SessionMode;
        WRITE: coreTypes.SessionMode;
    };
    error: {
        SERVICE_UNAVAILABLE: string;
        SESSION_EXPIRED: string;
        PROTOCOL_ERROR: string;
    };
    spatial: {
        isPoint: typeof isPoint;
    };
    temporal: {
        isDuration: typeof isDuration;
        isLocalTime: typeof isLocalTime;
        isTime: typeof isTime;
        isDate: typeof isDate;
        isLocalDateTime: typeof isLocalDateTime;
        isDateTime: typeof isDateTime;
    };
    Driver: typeof Driver;
    Result: typeof Result;
    Record: typeof Record;
    ResultSummary: typeof ResultSummary;
    Node: typeof Node;
    Relationship: typeof Relationship;
    UnboundRelationship: typeof UnboundRelationship;
    PathSegment: typeof PathSegment;
    Path: typeof Path;
    Integer: typeof Integer;
    Plan: typeof Plan;
    ProfiledPlan: typeof ProfiledPlan;
    QueryStatistics: typeof QueryStatistics;
    Notification: typeof Notification;
    ServerInfo: typeof ServerInfo;
    Session: typeof Session;
    Transaction: typeof Transaction;
    Point: typeof Point;
    Duration: typeof Duration;
    LocalTime: typeof LocalTime;
    Time: typeof Time;
    Date: typeof Date;
    LocalDateTime: typeof LocalDateTime;
    DateTime: typeof DateTime;
    ConnectionProvider: typeof ConnectionProvider;
    Connection: typeof Connection;
};
export { driver, int, isInt, isPoint, isDuration, isLocalTime, isTime, isDate, isLocalDateTime, isDateTime, integer, Neo4jError, auth, logging, types, session, error, spatial, temporal, Driver, Result, Record, ResultSummary, Node, Relationship, UnboundRelationship, PathSegment, Path, Integer, Plan, ProfiledPlan, QueryStatistics, Notification, ServerInfo, Session, Transaction, Point, Duration, LocalTime, Time, Date, LocalDateTime, DateTime, ConnectionProvider, Connection };
export type { QueryResult, AuthToken, Config, EncryptionLevel, TrustStrategy, SessionMode, ResultObserver, NotificationPosition, };
export default forExport;
